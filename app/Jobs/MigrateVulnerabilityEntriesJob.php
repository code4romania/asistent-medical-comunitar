<?php

declare(strict_types=1);

namespace App\Jobs;

use App\Models\Activity;
use App\Models\Beneficiary;
use App\Models\Vulnerability\VulnerabilityEntry;
use Carbon\Carbon;
use Illuminate\Bus\Batchable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;
use Illuminate\Foundation\Queue\Queueable;
use Illuminate\Support\Collection;
use Illuminate\Support\Str;
use Stringable;

class MigrateVulnerabilityEntriesJob implements ShouldQueue
{
    use Batchable;
    use Queueable;

    public array $beneficiaries;

    protected array $buffer = [];

    protected Collection $vulnerabilitiesMap;

    /**
     * First activity_log timestamp of subject_type disease.
     *
     * @var string
     */
    public string $cutoffDate = '2024-04-03 17:05:18';

    public bool $log = false;

    /**
     * Create a new job instance.
     */
    public function __construct(array $beneficiaries)
    {
        $this->beneficiaries = $beneficiaries;
    }

    /**
     * Execute the job.
     */
    public function handle(): void
    {
        Beneficiary::query()
            ->whereIn('id', $this->beneficiaries)
            ->with([
                'relatedActivities' => fn (HasMany $query) => $query
                    ->withoutGlobalScope('latest')
                    ->withoutEagerLoads()
                    ->where('log_name', 'catagraphy'),

                'catagraphy' => fn (HasOne $query) => $query
                    ->withoutEagerLoads()
                    ->with([
                        'diseases' => fn (HasMany $query) => $query
                            ->where('updated_at', '<', $this->cutoffDate)
                            ->withoutEagerLoads(),
                        'disabilities' => fn (HasMany $query) => $query
                            ->where('updated_at', '<', $this->cutoffDate)
                            ->withoutEagerLoads(),
                    ]),
            ])
            ->lazy()
            ->each(function (Beneficiary $beneficiary) {
                $currentCreatedAt = null;
                $activities = [];
                $vulnerabilitiesMap = collect();

                $this->log("Beneficiary {$beneficiary->id} with {$beneficiary->relatedActivities->count()} activities");

                $relatedActivities = $beneficiary->relatedActivities;

                foreach ($beneficiary->catagraphy->diseases as $disease) {
                    $relatedActivities->push(Activity::make([
                        'subject_type' => 'disease',
                        'subject_id' => $disease->id,
                        'properties' => [
                            'attributes' => $disease->only('type', 'category', 'rare_disease'),
                        ],
                        'created_at' => $disease->updated_at,
                    ]));
                }

                foreach ($beneficiary->catagraphy->disabilities as $disability) {
                    $relatedActivities->push(Activity::make([
                        'subject_type' => 'disability',
                        'subject_id' => $disability->id,
                        'properties' => [
                            'attributes' => $disability->only('type', 'degree', 'has_certificate'),
                        ],
                        'created_at' => $disability->updated_at,
                    ]));
                }

                $relatedActivities = $relatedActivities
                    ->sortBy('created_at')
                    ->values();

                $this->log('Related activities', [
                    'ids' => $relatedActivities,
                ]);

                foreach ($relatedActivities as $activity) {
                    if ($activity->created_at->diffInSeconds($currentCreatedAt, true) > 2) {
                        $this->flush(
                            $activities,
                            $vulnerabilitiesMap,
                            $beneficiary,
                            $currentCreatedAt
                        );

                        $currentCreatedAt = $activity->created_at;
                        $activities = [];
                    }

                    $activities[] = $activity;
                }

                $this->flush($activities, $vulnerabilitiesMap, $beneficiary, $currentCreatedAt);

                $this->log('End of activities loop', [
                    'activities_count' => \count($activities),
                    'buffer' => $this->buffer,
                ]);
                VulnerabilityEntry::insert($this->buffer);
                $this->buffer = [];
            });
    }

    protected function computeVulnerabilitiesMap(array $activities, Collection $previous): Collection
    {
        $add = collect();
        $remove = collect();

        foreach ($activities as $activity) {
            // process things that get added
            $add = $add->merge($this->generate($activity, 'attributes'));

            // process things that get removed
            $remove = $remove->merge($this->generate($activity, 'old'));
        }

        $add = $add->countBy();
        $remove = $remove->countBy();

        $map = collect()
            ->concat($previous->keys())
            ->concat($add->keys())
            ->concat($remove->keys())
            ->mapWithKeys(fn (string $key) => [
                $key => (int) $previous->get($key) + (int) $add->get($key) - (int) $remove->get($key),
            ])
            ->filter(fn (int $value) => $value > 0)
            ->sortKeys();

        $this->log('computeVulnerabilitiesMap', [
            'activity_ids' => collect($activities)->pluck('id')->all(),
            'previous' => $previous->all(),
            'add' => $add->all(),
            'remove' => $remove->all(),
            'result' => $map->all(),
        ]);

        return $map;
    }

    protected function generate(Activity $activity, string $key): Collection
    {
        $properties = collect($activity->properties->get($key));
        $result = collect();

        if (
            $activity->subject_type === 'beneficiary' ||
            $activity->subject_type === 'catagraphy'
        ) {
            $result = $properties
                ->filter(
                    fn (mixed $value, string $key): bool => filled($value) &&
                        Str::startsWith($key, 'cat_')
                )
                ->flatten();
        }

        if ($activity->subject_type === 'disease') {
            $result->push($properties->get('type'));
            $result->push($properties->get('category'));
            $result->push($properties->get('rare_disease'));
        }

        if ($activity->subject_type === 'disability') {
            $result->push($properties->get('type'));
            $result->push($properties->get('degree'));
            $result->push(
                (bool) $properties->get('has_certificate')
                    ? 'VDH_01'
                    : 'VDH_02'
            );
        }

        if ($activity->subject_type === 'suspicion') {
            $result->push($properties->get('category'));

            collect($properties->get('elements'))
                ->each(fn (string $element) => $result->push($element));
        }

        return $result
            ->filter()
            ->sort();
    }

    protected function flush(array $activities, Collection &$previous, Beneficiary $beneficiary, ?Carbon $currentCreatedAt = null): void
    {
        if (blank($activities)) {
            return;
        }

        $vulnerabilitiesMap = $this->computeVulnerabilitiesMap(
            $activities,
            $previous,
        );

        if ($vulnerabilitiesMap->isNotEmpty()) {
            $currentCreatedAt ??= $activities[0]->created_at;

            $this->buffer[] = [
                'beneficiary_id' => $beneficiary->id,
                'map' => $vulnerabilitiesMap->toJson(\JSON_FORCE_OBJECT),
                'created_at' => $currentCreatedAt->toDateTimeString(),
            ];
        }

        $previous = $vulnerabilitiesMap;
    }

    protected function log(string|Stringable $message, array $context = [])
    {
        if (! $this->log) {
            return;
        }

        logger()->info($message, $context);
    }
}
